## Описание проекта

Данный проект представляет собой консольное приложение для управления личными финансами. Он реализует основные CRUD-операции (создание, чтение, обновление, удаление) для трех ключевых доменных сущностей: банковских счетов (`BankAccount`), категорий (`Category`) и финансовых операций (`Operation`).

Ключевой особенностью проекта является его архитектура, построенная на принципах SOLID и GRASP с применением 8 паттернов проектирования GoF. Система разделена на четкие слои (UI, Facades, Services, Repositories, Storage, Domain), что обеспечивает High Cohesion and Low Coupling и хорошую расширяемость. Для управления зависимостями используется DI-контейнер `Boost.DI`.

## Быстрый запуск

**Требования:**
*   **CMake** (версия 3.28 или выше)
*   **Компилятор C++** с поддержкой стандарта C++20

#### Сборка и запуск из командной строки:

1.  **Клонировать репозиторий**
    ```bash
    git clone <адрес_репозитория>
    cd <папка_проекта>
    ```

2.  **Создать директорию для сборки**
    ```bash
    mkdir build
    cd build
    ```

3.  **Сконфигурировать проект с помощью CMake**
    (Эта команда найдет компилятор и сгенерирует файлы для сборки)
    ```bash
    # Для Linux / macOS
    cmake ..

    # Для Windows
    cmake -G "MinGW Makefiles" ..
    ```

5.  **Скомпилировать проект**
    ```bash
    cmake --build .
    ```

6.  **Запустить приложение**
    Исполняемый файл `Finance_App` появится в папке `build`.
    ```bash
    # Для Linux / macOS
    ./Finance_App

    # Для Windows
    Finance_App.exe
    ```

## Структура директорий

Структура проекта организована по принципу слоистой архитектуры, где каждая директория имеет четко определенную зону ответственности.

```bash
Finance_App/
├── src/
│ ├── main.cpp
│ ├── boost/
│ │ ├── di/
│ │ └── di.hpp
│ ├── analytics/
│ │ ├── GroupByCategoriesStrategy.h
│ │ ├── IAnalyticsStrategy.h
│ │ └── IncomeExpenseDifferenceStrategy.h
│ ├── commands/
│ │ ├── CreateAccountCommand.h
│ │ ├── GenerateReportCommand.h
│ │ ├── ICommand.h
│ │ ├── RemoveAccountCommand.h
│ │ ├── TimingDecorator.h
│ │ └── UpdateAccountNameCommand.h
│ ├── core/
│ │ ├── IObserver.h
│ │ └── ISubject.h
│ ├── domain/
│ │ ├── BankAccount.h, BankAccount.cpp
│ │ ├── Category.h, Category.cpp
│ │ ├── Operation.h, Operation.cpp
│ │ └── OperationBuilder.h, OperationBuilder.cpp
│ ├── facades/
│ │ ├── AccountFacade.h, AccountFacade.cpp
│ │ ├── AnalyticsFacade.h, AnalyticsFacade.cpp
│ │ ├── CategoryFacade.h, CategoryFacade.cpp
│ │ ├── IAccountFacade.h
│ │ ├── IAnalyticsFacade.h
│ │ ├── ICategoryFacade.h
│ │ └── IOperationFacade.h
│ │ └── OperationFacade.h, OperationFacade.cpp
│ ├── repository/
│ │ ├── AccountRepository.h, AccountRepository.cpp
│ │ ├── BankAccountRepository.h
│ │ ├── CategoryRepository.h, CategoryRepository.cpp
│ │ ├── IRepository.h
│ │ └── OperationRepository.h, OperationRepository.cpp
│ ├── services/
│ │ ├── DomainEntityFactory.h, DomainEntityFactory.cpp
│ │ ├── IIdGenerator.h
│ │ ├── OperationService.h, OperationService.cpp
│ │ └── SequentialIdGenerator.h
│ ├── storage/
│ │ ├── IStorage.h
│ │ └── InMemoryStorage.h, InMemoryStorage.cpp
│ └── ui/
│ ├── ConsoleUI.h, ConsoleUI.cpp
│ └── InputHelper.h
└── CMakeLists.txt
```

## Описание архитектуры по слоям

Система построена на принципах слоистой архитектуры. Запрос от пользователя проходит через следующие слои:

1.  **UI (`ConsoleUI`)**: Отвечает за взаимодействие с пользователем. Отображает меню, принимает и валидирует формат ввода (`InputHelper`). Для выполнения действий связаныых с аналитикой и AccountFacade `ConsoleUI` создает объекты-**Команды**. В остальных случаях идет прямое взаимодействие с фасадом.
2.  **Commands (`ICommand`)**: Инкапсулирует запрос пользователя в объект. Команда ничего не знает о бизнес-логике, она просто вызывает соответствующий метод **Фасада**.
3.  **Facades (`IAccountFacade`, etc.)**: Являются "мозгом" приложения и точкой входа в бизнес-логику. Фасад организует взаимодействие между нижележащими слоями: запрашивает ID у генератора, просит **Фабрику** создать объект, передает его в **Репозиторий** и уведомляет **Сервисы**. Фасады также обрабатывают ошибки.
4.  **Services (`OperationService`, etc.)**: Реализуют конкретную функциональность или сложную бизнес-логику. Например, `OperationService` реализует паттерн **Наблюдатель**.
5.  **Repository (`IRepository`)**: Предоставляет абстрактный API для доступа к данным (CRUD). Слой Фасадов зависит только от этих интерфейсов.
6.  **Storage (`IStorage`)**: Низкоуровневая абстракция, отвечающая за физическое хранение данных. Конкретная реализация `InMemoryStorage` использует `std::unordered_map` для хранения объектов.

## Принципы проектирования (SOLID / GRASP)

*   **SRP (Single Responsibility Principle)**: Каждый класс имеет одну зону ответственности. `InputHelper` отвечает только за ввод. `OperationBuilder` — только за сборку операции. `AccountRepository` — только за хранение счетов.
*   **OCP (Open/Closed Principle)**: Система открыта для расширения, но закрыта для модификации.
    *   **Аналитика**: Можно добавить новый вид отчета, создав новый класс-`Стратегию` и зарегистрировав его в `main.cpp`, не изменяя `AnalyticsFacade` или `ConsoleUI`.
    *   **Статистика**: `TimingDecorator` может быть применен к любой новой `Команде` без изменения ее кода.
*   **LSP (Liskov Substitution Principle)**:
    *   **Фасады**: `DI-контейнер` и `ConsoleUI` работают с абстракциями, такими как `IAccountFacade`. Им можно "подставить" любую реализацию этого интерфейса (`AccountFacade` или `MockAccountFacade` для тестирования), и программа продолжит работать корректно, так как все реализации выполняют один и тот же контракт.
    *   **Стратегии**: `AnalyticsFacade` работает с интерфейсом `IAnalyticsStrategy` и может выполнить любой конкретный отчет (`IncomeExpenseDifferenceStrategy`, `GroupByCategoriesStrategy`), не зная о деталях его реализации. Любая новая стратегия, реализующая этот интерфейс, будет корректно работать с фасадом.
    *   **Команды**: `TimingDecorator` и `ConsoleUI` работают с общим интерфейсом `ICommand`, что позволяет им выполнять любую конкретную команду (`CreateAccountCommand`, `GenerateReportCommand`), не зная о ее внутреннем устройстве.
*   **ISP (Interface Segregation Principle)**: Большие интерфейсы разделены на маленькие и конкретные. Вместо одного `IFinanceFacade` созданы `IAccountFacade`, `ICategoryFacade` и `IOperationFacade`. Благодаря этому, `CreateAccountCommand` зависит только от `IAccountFacade`, а не от методов для работы с операциями.
*   **DIP (Dependency Inversion Principle)**: Все слои зависят от абстракций, а не от конкретных реализаций. `Facades` зависят от `IRepository` и `IStorage`, а не от `AccountRepository` и `InMemoryStorage`. Этот принцип реализуется с помощью **DI-контейнера `Boost.DI`**, который собирает все зависимости в `main.cpp`.
*   **GRASP - High Cohesion & Low Coupling**: Принципы SOLID приводят к высокой сплоченности (классы делают одну вещь) и низкой связности (модули общаются через абстрактные интерфейсы).
*   **GRASP - Protected Variations**: Система защищена от изменений. Использование интерфейса `IStorage` защищает репозитории от смены способа хранения. Неизменяемость типа `Operation` защищает систему от сложной логики, связанной с изменением сути транзакции.

## Использованные паттерны проектирования

### Порождающие (Creational)

**1. Одиночка (Singleton)**
*   **Где применяется:** `InMemoryStorage`.
*   **Зачем применяется:** Гарантирует существование единственного экземпляра in-memory базы данных для всего приложения, предоставляя к нему глобальную точку доступа `GetInstance()`. Это обеспечивает целостность данных.

**2. Фабрика (Factory)**
*   **Где применяется:** `DomainEntityFactory`.
*   **Зачем применяется:** Инкапсулирует и централизует создание простых доменных объектов (`BankAccount`, `Category`). Это упрощает код Фасадов и отделяет их от деталей конструирования.

**3. Строитель (Builder)**
*   **Где применяется:** `OperationBuilder`.
*   **Зачем применяется:** Для пошагового создания сложного объекта `Operation` с множеством полей, включая опциональные. Паттерн обеспечивает валидность создаваемого объекта и делает код его конструирования более читаемым.

### Структурные (Structural)

**4. Фасад (Facade)**
*   **Где применяется:** `AccountFacade`, `CategoryFacade`, `OperationFacade`.
*   **Зачем применяется:** Предоставляет простой и сфокусированный интерфейс для сложной подсистемы. Каждый фасад скрывает детали взаимодействия с репозиториями, фабриками и сервисами, предоставляя `UI` и `Командам` высокоуровневый API.

**5. Декоратор (Decorator)**
*   **Где применяется:** `TimingDecorator` для аналитики.
*   **Зачем применяется:** Для динамического добавления функциональности к объектам. `TimingDecorator` "оборачивает" любой объект `ICommand` и добавляет к его выполнению замер времени, не изменяя исходный код команды. Это реализует опциональное требование по сбору статистики. Используется для замера времени аналитки, но в дальнейшем можно обернуть по желанию любой объект, что реализует `ICommand`, так как `TimingDecorator` зависит только от абстракции `ICommand`.

### Поведенческие (Behavioral)

**6. Команда (Command)**
*   **Где применяется:** `CreateAccountCommand`, `GenerateReportCommand` и др.
*   **Зачем применяется:** Инкапсулирует запрос на выполнение действия в виде объекта. Это полностью отделяет `UI` (инициатора запроса) от `Фасадов` (исполнителей) AnalyticsFacade и AccountFacade, можно сделать аналогичные команды и для других фасадов. `UI` просто создает и выполняет команду, не зная о деталях ее реализации.

**7. Наблюдатель (Observer)**
*   **Где применяется:** `OperationService` (Субъект) и `BankAccount` (Наблюдатель).
*   **Зачем применяется:** Для автоматического обновления баланса счетов при создании (`OnAdd`) или удалении (`OnDelete`) операций. Паттерн создает слабую связь между компонентами: сервис операций ничего не знает о счетах, он лишь уведомляет подписчиков через интерфейс `IObserver`.

**8. Стратегия (Strategy)**
*   **Где применяется:** `IAnalyticsStrategy` и его реализации (`IncomeExpenseDifferenceStrategy`, `GroupByCategoriesStrategy`).
*   **Зачем применяется:** Для инкапсуляции различных алгоритмов генерации отчетов. `AnalyticsFacade` использует эти стратегии, не зная деталей их реализации. Благодаря OCP-совместимому дизайну с регистрацией, можно добавлять новые виды отчетов, не изменяя код Фасада или `UI`.
